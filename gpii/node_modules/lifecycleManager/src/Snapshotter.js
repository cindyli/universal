/*!
 * Snapshotter
 *
 * Copyright 2018 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    fs = require("fs"),
    JSON5 = require("json5");

fluid.defaults("gpii.snapshotter", {
    gradeNames: ["fluid.modelComponent"],
    // The path to the file that has all QSS supported settings
    qssSettingsFilePath: "%gpii-universal/testData/solutions/qssSupported.json5",
    model: {
        snapshottedSettings: {}, // Holds original settings that QSS supports
        provenance: {}
    },
    events: {
        onPrepareCapture: null,
        onPrepareSolutions: null,
        onSolutions: null,
        onReadyToCapture: {
            events: {
                prepareCapture: "onPrepareCapture",
                prepareSolutions: "onPrepareSolutions",
                solutions: "onSolutions"
            },
            args: [
                "{arguments}.solutions.0",
                "{arguments}.prepareCapture.0"
            ]
        },
        onGetSolutionError: null,
        onError: null
    },
    listeners: {
        "onCreate.start": "{that}.events.onPrepareCapture.fire",
        "onPrepareCapture.deviceContext": {
            funcName: "gpii.flowManager.getDeviceContext",
            args: ["{flowManager}.deviceReporterDataSource", "{that}.events.onPrepareSolutions"]
        },
        "onPrepareSolutions.getSolutions": {
            func: "{that}.getSolutions",
            args: ["{arguments}.0"]
        },
        "onReadyToCapture.takeSnapshot": {
            func: "{that}.takeSnapshot",
            args: ["{arguments}.0", "{arguments}.1"]
        },
        "onGetSolutionError.log": {
            funcName: "fluid.log",
            args: ["=== Error at retrieving solutions: ", "{arguments}.0"]
        }
    },
    invokers: {
        getSolutions: {
            funcName: "gpii.flowManager.getSolutions",
            args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0", "{that}.events.onSolutions", "{that}.events.onGetSolutionError"]
        },
        takeSnapshot: {
            funcName: "gpii.snapshotter.takeSnapshot",
            args: ["{that}", "{lifecycleManager}.invokeSettingsHandlerGet", "{lifecycleManager}.variableResolver", "{arguments}.0"]
        }
    }
});

/**
 * Runs through all QSS supported solutions, pulls the current
 * setting for each supportedSetting and returns them in an object. Primary use case
 * is for backing Capture tools that would allow a user to set up their GPII profile
 * starting with the current settings for their applications on the local machine.
 *
 * @param {Component} that - An instance of gpii.snapshotter
 * @param {Function} invokeSettingsHandlerGet - lifecycleManager.invokeSettingsHandlerGet to get intial setting
 * @param {lifecycleManager.variableResolver} resolver - Resolver for looking up handler specifications
 * @param {Object} solutions - Solutions registry entries for solutions available on the current machine.
 */
gpii.snapshotter.takeSnapshot = function (that, invokeSettingsHandlerGet, resolver, solutions) {
    var qssSupportedSolutions = JSON5.parse(fs.readFileSync(fluid.module.resolvePath(that.options.qssSettingsFilePath), "utf-8"));
    var qssCommonTerms = fluid.keys(qssSupportedSolutions);
    var qssSolutions = fluid.values(qssSupportedSolutions);

    var handlerGetPromises = [];
    fluid.each(solutions, function (solution, solutionID) {
        // Only find original settings for QSS supported
        if (qssSolutions.indexOf(solutionID) === -1) {
            return;
        }

        var newSolution = gpii.lifecycleManager.transformSolutionSettings(solution, gpii.settingsHandlers.changesToSettings);
        fluid.each(newSolution.settingsHandlers, function (handlerSpec) {
            //if applicationSettings is unspecified, dont attempt to get settings
            if (!handlerSpec.supportedSettings) {
                return;
            }

            handlerSpec.settings = handlerSpec.supportedSettings;
            handlerSpec = resolver.resolve(handlerSpec, {});
            fluid.log("=== snapshotter, handling solutionID: ", solutionID);
            handlerGetPromises.push(invokeSettingsHandlerGet(solutionID, handlerSpec));
        });
    });
    var promisesSequence = fluid.promise.sequence(handlerGetPromises);
    promisesSequence.then(function (snapshottedSettings) {
        fluid.log("=== Snapshotter success snapshottedSettings: ", snapshottedSettings);
        that.applier.change("snapshottedSettings", snapshottedSettings);

        // // Populate model.provenance based on the settings found
        // var provenance = {};
        // fluid.each(snapshottedSettings, function (value, solutionId) {
        //     fluid.set(provenance, solutionID, "snapshot");
        // });
        // that.applier.change("provenance", provenance);
    }, function (error) {
        fluid.log("=== Snapshotter error: ", error);
        that.events.onError.fire(error);
    });
};
